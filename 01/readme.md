# Lesson 1: Introduction to Node.js

Objective: Understand what Node.js is and how it differs from browser-based JavaScript.
Topics Covered:
- Node.js architecture
- Event-driven programming
- Non-blocking I/O
- What is Node.js?

# 9 - кратко
Node.js — это среда выполнения JavaScript, созданная на основе движка JavaScript V8 от Chrome.
Она позволяет запускать JavaScript на стороне сервера, что позволяет создавать масштабируемые и 
высокопроизводительные сетевые приложения.
Node.js произвел революцию в использовании JavaScript вне браузеров.
Node.js особенно хорошо подходит для создания приложений, 
требующих взаимодействия в реальном времени или обрабатывающих множество одновременных подключений.


# 10 - применение
- Web servers
- Real-time applications (e.g., chat applications, gaming servers)
- Command-line tools
- IoT applications

# 20 - eventloop
1 фаза — таймеры
Данная фаза выполняется непосредственно Event Loop'ом. (Фрагмент кода с uv_update_time) — здесь просто обновляется время, когда начал работать Event Loop.

uv_run_timers — в этом методе выполняется следующее действие с таймером. Есть определённый стек, точнее, куча таймеров, это, по сути, то же самое, что очередь, где находятся таймеры. Берётся таймер с самым маленьким временем, сравнивается с текущим времени Event Loop'а, и, если настало время для исполнения данного таймера, выполняется его callback. Здесь стоит отметить что в Node.js есть реализация setTimeout и есть setInterval. Для libuv это, по сути, одно и то же, только в setInterval ещё есть флаг repeat.

Соответственно, если у данного таймера стоит флаг repeat, то он снова помещается в очередь событий и потом точно так же обрабатывается.

2 фаза — I/O-callback'и

Здесь надо вернуться к диаграмме про неблокирующий ввод/вывод.

Когда демультиплексор событий выполняет чтение какого-либо файла и ставит выполнение callback'а в очередь, это как раз соответствует этапу I/O-callback. Здесь выполняются callback'и для неблокирующего ввода/вывода, т. е. это именно те функции, которые используются после запроса в базу данных или другой ресурс или на чтение/запись файла. Они выполняются именно на данной фазе.

На слайде 9 выполнение функции I/O-callback'и запускает строка 367: ran_pending = uv_run_pending(loop).

3 фаза — ожидание, подготовка

Это внутренние операции для callback'ов, по сути, мы не можем влиять на фазу, только косвенно. Есть process.nextTick, его callback может ненамеренно быть исполнен на фазе «ожидание, подготовка». process.nextTick выполняется на текущей фазе, т. е., по сути, process.nextTick может сработать абсолютно на любой фазе. Какого-то готового инструмента, чтобы запустить код на фазе «ожидание, подготовка», в Node.js нет.


4 фаза — опрос

Здесь выполняется весь наш код, который мы пишем на JS. Первоначально все запросы, которые мы делаем, попадают именно сюда, и именно здесь Node.js может быть заблокирована. Если сюда попадёт какая-либо тяжёлая операция по вычислению, то на этом этапе наше приложение может просто зависнуть и ожидать, пока не выполнится данная операция.
На слайде 9 функция опроса содержится в строке 370: uv_io_poll(loop, timeout).

5 фаза — проверка

В Node.js есть таймер setImmediate, его callback'и выполняются на этой фазе.

6 фаза (последняя) — callback'и событий close

Например, web-сокету нужно закрыть соединение, на этой фазе будет вызван callback этого события.